import os
import subprocess
import pandas as pd
import psycopg
from tqdm import tqdm
import random
from datetime import datetime
import argparse
import re
from dotenv import load_dotenv

load_dotenv('config/postgresql.cfg')

DB_USER = os.getenv('DB_USER')
DB_PASSWORD = os.getenv('DB_PASSWORD')
DB_HOST = os.getenv('DB_HOST')
DB_PORT = os.getenv('DB_PORT')
DB_NAME = os.getenv('DB_NAME')


Distritos_Sigla = {   
    'Açores':'Ac',
    'Aveiro':'Av',
    'Beja': 'BJ',
    'Braga':'Br',
    'Bragança':'Bg',
    'Castelo Branco': 'Cb',
    'Coimbra' : 'Co',
    'Évora' : 'Ev',
    'Faro':'Fr',
    'Guarda': 'Gr',
    'Leiria': 'Lr',
    'Lisboa': 'Lx',
    'Madeira': 'Md',
    'Portalegre':'Pr',
    'Porto':'Po',
    'Santarém':'Sr',
    'Setúbal':'St',
    'Viana do Castelo': 'Vc',
    'Vila Real':'Vr',
    'Viseu':'Vs'
}

Sigla_Distritos = {   
    'Ac':'Açores',
    'Av':'Aveiro',
    'Bj':'Beja',
    'Br':'Braga',
    'Bg':'Bragança',
    'Cb':'Castelo Branco',
    'Co':'Coimbra',
    'Ev':'Évora',
    'Fr':'Faro',
    'Gr':'Guarda',
    'Lr':'Leiria',
    'Lx':'Lisboa',
    'Md':'Madeira',
    'Pr':'Portalegre',
    'Po':'Porto',
    'Sr':'Santarém',
    'St':'Setúbal',
    'Vc':'Viana do Castelo',
    'Vr':'Vila Real',
    'Vs':'Viseu'
}

def process_line(line):

    if "National" in line or "Mypharma" in line:
        return False
    return True

# Função para processar a string
# regex = r"(?P<brick>\d{3})\s+(?P<Distrito>\w{2})\s+-\s+(?P<Regiao>[^;]+?)(?:\s+\((?P<Freguesia>[^)]+)\))?;\s+(?P<Produto>\w+);\s*(?P<Quantidade>\d+)"
regex = r"(?P<brick>\d{3})\s+(?P<Distrito>\w{2})\s+-\s+(?P<Regiao>[^;]+?)(?:\s+\((?P<Freguesia>[^)]+\)))?;?$"
def extrair_dados(texto):
    match = re.match(regex, texto)
    if match:
        return match.groupdict()  # Retorna os grupos como dicionário
    else:
        return None  # Retorna None se não houver correspondência

linha_regex = r'^(.*?);\s*(.*?);\s*(\d+)$'
def extrair_linha(texto):
    match = re.match(linha_regex, texto)
    if match:
        return match.groupdict()  # Retorna os grupos como dicionário
    else:
        return None  # Retorna None se não houver correspondência



conn_string = f"postgresql://{DB_USER}:{DB_PASSWORD}@{DB_HOST}:{DB_PORT}/{DB_NAME}"

parser = argparse.ArgumentParser(description="Load mypharma monthly file")
parser.add_argument("path", help="path to file")

args = parser.parse_args()


def find_most_recent_csv(directory):
    month = 0
    year = 0

    # Regex para capturar o formato mm_yy nos nomes dos ficheiros .csv
    pattern = r"(\d{2})_(\d{2})\.csv"
    
    most_recent_file = None
    most_recent_date = None

    # Listar todos os ficheiros na diretoria
    for filename in os.listdir(directory):
        print("Filename: ", filename)

        # Verificar se o ficheiro é .csv e segue o padrão
        match = re.match(pattern, filename)
        if match:
            # Extrair o mês e ano
            month = int(match.group(1))
            year = int(match.group(2)) + (2000 if int(match.group(2)) < 100 else 0)  # Ajustar para anos 2000+
            
            # Criar uma data para comparação
            file_date = datetime(year, month, 1)
            
            # Verificar se é a data mais recente
            if most_recent_date is None or file_date > most_recent_date:
                most_recent_date = file_date
                most_recent_file = filename

    return most_recent_file, month, year


# Paths
input_file = "scripts/hmr_mp_agt.py"            # Generates the cleaned CSV

# Step 1: Run the input script to generate the cleaned data
print(f"Running input script: {input_file}...")
try:
    subprocess.call(['python', input_file, args.path])
    print(f"Input file {input_file} executed successfully.")
except subprocess.CalledProcessError as e:
    print(f"Failed to execute {input_file}!")
    print(e.stderr)
    exit(1)

cleaned_csv, month, year = find_most_recent_csv("uploads/mypharma_csv/")  # File generated by detetor.py
df = pd.read_csv('uploads/mypharma_csv/' + cleaned_csv, delimiter=';', encoding='utf-8')

registry_date = datetime(year,month,1)

# Step 3: Insert data into the database
print("Inserting data into the database...")
with psycopg.connect(conn_string) as conn:
    with conn.cursor() as cur:
        try:
            cur.execute('BEGIN')  # Start transaction
            
            for _, row in tqdm(df.iterrows(), total=len(df)):
                if (process_line(row['Region'].strip()) and process_line(row['Entity'].strip())):
                    # print(str(row))
                    
                    fields_region = extrair_dados(row['Region'].strip())

                    # region_name = row[0].strip()
                    # entity_name = row[1].strip()
                    # so_units = int(row[2].strip())
                    # so_units = row[2]  # Ensure it's an integer
                    
                    
                    #print("FIELDS: ", fields_region)

                    if fields_region:
                        brick = fields_region['brick'].strip()
                        district = fields_region['Distrito'].strip()
                        region_name = fields_region['Regiao'].strip()
                        town_name = fields_region['Freguesia']
                        product_name = row['Entity'].strip()
                        so_units = int(row['SO_Units'])

                        # print(str(region_name) + " " + str(product_name) + " " + str(so_units))

                        # Insert or find Region
                        cur.execute(f"SELECT id_region FROM region WHERE name = '{region_name}';")
                        region = cur.fetchone()
                        if region is None:
                            cur.execute(f"INSERT INTO region (name) VALUES ('{region_name}') RETURNING id_region;")
                            region = cur.fetchone()
                        region_id = region[0]


                        # District
                        cur.execute(f"SELECT id_district FROM district WHERE name = '{Sigla_Distritos[district]}';")
                        district = cur.fetchone()
                        if district is None:
                            cur.execute(f"INSERT INTO district (name) VALUES ('{Sigla_Distritos[district]}') RETURNING id_district;")
                            district = cur.fetchone()
                        district_id = district[0]
                        
                        # Town
                        town_id = None
                        if town_name:
                            cur.execute(f"SELECT id_town FROM town WHERE name = '{town_name.strip()}';")
                            town = cur.fetchone()
                            if town is None:
                                cur.execute(f"INSERT INTO town (name) VALUES ('{town_name.strip()}') RETURNING id_town;")
                                town = cur.fetchone()
                            town_id = town[0]
                        
                        # entity_parts = entity_name.split(" - ")
                        # company = entity_parts[0].strip()
                        # product = entity_parts[1].strip() if len(entity_parts) > 1 else None
                        # pack = entity_parts[2].strip() if len(entity_parts) > 2 else None

                        # # Insert or find Company
                        cur.execute(f"SELECT id_company FROM company WHERE name = 'MyPharma';")
                        company = cur.fetchone()
                        if company is None:
                            cur.execute(f"INSERT INTO company (name) VALUES ('MyPharma') RETURNING id_company;")
                            company = cur.fetchone()
                        company_id = company[0]

                        # Insert or find Product
                        if product_name:
                            cur.execute(f"""
                                SELECT cnp FROM product WHERE name = '{product_name}' AND fk_id_company = {company_id};
                            """)
                            product = cur.fetchone()
                            if product is None:
                                cur.execute(f"""
                                INSERT INTO product (cnp, name, fk_id_company) 
                                VALUES ({random.randint(1, 1000000000)}, '{product_name}', {company_id}) 
                                RETURNING cnp;
                            """)
                                product = cur.fetchone()
                            product_id = product[0]
                        else:
                            product_id = None  # If no product, handle appropriately

                        # Insert or find Sale for the given date (August 1st, current year)
                        cur.execute(f"""
                            SELECT id_sale FROM sale 
                            WHERE fk_brick = {brick} AND registry_date = '{registry_date}';
                        """)
                        sale = cur.fetchone()
                        if sale is None:
                            cur.execute(f"""
                                INSERT INTO sale (registry_date, fk_brick) 
                                VALUES ('{registry_date}', {brick}) 
                                RETURNING id_sale;
                            """)
                            sale = cur.fetchone()
                        sale_id = sale[0]

                        # Insert SO_Units into sale_product table
                        if product_id:
                            cur.execute(f"""
                                INSERT INTO sale_product (fk_id_sale, fk_cnp, product_amount) 
                                VALUES (
                                    {sale_id}, 
                                    {product_id}, 
                                    {so_units}
                                ) 
                                ON CONFLICT DO NOTHING;
                            """)

            conn.commit()  # Commit everything

        except Exception as e:
            print("Error inserting new values from file:", e)
            conn.rollback()  # Rollback on error

        try:
            cur.execute('BEGIN')  
            cur.execute('REFRESH MATERIALIZED VIEW general_table')
            cur.execute('REFRESH MATERIALIZED VIEW general_table_per_years')
            cur.execute('REFRESH MATERIALIZED VIEW general_delegates_and_bricks')
            
            conn.commit()
            print("Views refreshed successfully.")
        except Exception as e:
            print("Could not refresh views: ", e)
            conn.rollback()